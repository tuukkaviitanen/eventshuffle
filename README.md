# Eventshuffle API

> HTTP API to help schedule events with friends. For a pre-interview exercise.

Running live at https://eventshuffle.tuukka.net

## How to run locally

### Development build with live-reload

1. Make sure [Docker](https://www.docker.com/) is installed
2. Run `docker compose -f docker-compose.dev.yaml up`
3. Open https://localhost:3000 in your browser

#### For database changes

- `bunx prisma generate` for generating the Prisma client locally
- `bunx prisma migrate dev` for generating new migrations after Prisma schema changes
- `bunx prisma migrate deploy` for running existing migrations

### Production build

1. Make sure [Docker](https://www.docker.com/) is installed
2. Run `docker compose -f docker-compose.prod.yaml up`
3. Open http://localhost:3000 in your browser

## Requirements

- API contract provided [here](https://gist.github.com/VilluNikolaiV/44eae2829f7ece9c0d0657d502ed8c63)
- Short development time (a few hours)
- Easily maintainable and scalable
- Tests
- README with instructions for usage

## Plan

- Application written in [TypeScript](https://www.typescriptlang.org/) using [Bun](https://bun.sh/), [Elysia](https://elysiajs.com/) and [Prisma](https://www.prisma.io/)
  - This stack offers built-in full type-safety from the API to the database, minimizing the time spent debugging and enhances maintainability\*
    - Bun offers built-in TypeScript support, bundler, test runner and many more libraries that would have to be installed and setup separately when using [Node.js](https://nodejs.org/en), the most popular alternative
    - Elysia is a backend web framework built specifically for Bun and offers full type-safety with its a built-in parameter validator
    - Prisma is an [ORM](https://www.freecodecamp.org/news/what-is-an-orm-the-meaning-of-object-relational-mapping-database-tools/) that supports TypeScript and requires very little setup

  - Using an ORM to automatically apply some optimizations like [connection pooling](https://www.cockroachlabs.com/blog/what-is-connection-pooling/) and protection against threats like [SQL injection](https://www.w3schools.com/sql/sql_injection.asp). Managing the database schema with Prisma can be more maintainable as the project scales.
  - Some alternatives
    - [C#](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/overview)
      - Better performance under load, more resource efficient and offers [Entity Framework Core](https://learn.microsoft.com/en-us/ef/core/) for more advanced database operations and data processing\*
    - [Go](https://go.dev/)
      - Even better performance and resource efficiency, but not as advanced tools for database operations. The most popular ORM, [GORM](https://gorm.io/index.html), is not as feature-rich, as it's not type-safe as is.\*

- Using [PostgreSQL](https://www.postgresql.org/) as the database, as it's feature-rich, open-source and allows the application to be [horizontally scaled](https://www.cockroachlabs.com/blog/vertical-scaling-vs-horizontal-scaling/), by removing state from the application file-system.
  - A strong alternative that would make sense for this project would be [SQLite](https://www.sqlite.org/), which would create a database file in the application's local file-system
    - Wouldn't have to set up a completely separate database instance
    - Since the state would be stored locally in the application image, horizontal scaling, as in running multiple instances of the server at the same time to enhance availability, would be off the table
  - Another alternative would be [MongoDB](https://www.mongodb.com/), as it allows nested data structures, which would be useful in this project. However, for future development, features like user management would be easier to implement with a relational database, due to more advanced relation handling.
  - This choice could be considered as premature optimization, **but** room for scalability was an explicit requirement

- Using [ESLint](https://eslint.org/) for enforcing popular coding styles and [Prettier](https://prettier.io/) for code formatting
- Creating API tests with Bun's and Elysia's testing tools to enforce the API schema
- Using a service layer to separate the API from the business logic
- Using a [GitHub Actions](https://github.com/features/actions) workflow for CI
  - Verifying that the linter, build and tests pass
  - Tagging each main branch commit with a semantic version and publishing a Docker image from it
- Deploying the application to my own hosting environment

\* Based on findings from my thesis: [A comparative analysis of modern programming languages in REST API development](https://www.theseus.fi/handle/10024/884660)

## Current state

- The API contract is fully implemented with persisting storage
- User inputs are validated with descriptive validation errors
- Semi-automatically generated [Swagger UI](https://swagger.io/tools/swagger-ui/) for API documentation
  - The documentation is generated by the same contract as the validator, so it stays up-to-date with any changes
  - Still partial as only the endpoints and parameters are documented
- Some unit tests for a helper function
  - API tests not yet implemented due to time constraints
- CI pipeline verifies code style, code formatting, bundling and tests. Production Docker images are versioned with the commit's semantic version and published to [GitHub Container Registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry).
- The latests published Docker image is automatically deployed to https://eventshuffle.tuukka.net
  - My hosting setup automatically polls new image versions using [watchtower](https://containrrr.dev/watchtower/) every 5 minutes
- Overall, the foundations for the application are well made and it will be pleasant to maintain and scale further

## Ideas for future

- API tests to enforce API schema
- API responses documented with OpenAPI/Swagger
- Ability to remove votes
- Ability to see expanded results, for example, if none of the dates are full suitable for everyone, see which would be most suitable
- User management
  - Friend groups
- Further optimized production Docker image size
  - Current size, +400MB, could most likely be halved to increase deployment time and decrease to attack surface
